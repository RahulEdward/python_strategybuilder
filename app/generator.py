"""
Code Generator Module for FastAPI Strategy Builder
Generates Python trading strategy code from parsed configurations
"""
import logging
from typing import Dict, List, Any, Optional
from datetime import datetime
import os
import json

# Setup logging
logger = logging.getLogger(__name__)

class CodeGenerator:
    """Main code generator class for trading strategies"""
    
    def __init__(self, templates_dir: str = "templates"):
        """Initialize the code generator"""
        self.templates_dir = templates_dir
        self.generated_strategies = []
        
        # Define indicator calculation templates
        self.indicator_templates = {
            "RSI": self._generate_rsi_code,
            "EMA": self._generate_ema_code,
            "SMA": self._generate_sma_code,
            "MACD": self._generate_macd_code,
            "BB": self._generate_bb_code,
            "STOCH": self._generate_stoch_code,
            "CCI": self._generate_cci_code,
            "WILLIAMS": self._generate_williams_code,
            "ATR": self._generate_atr_code,
            "ADX": self._generate_adx_code
        }
        
        # Define operator templates
        self.operator_templates = {
            "above": ">",
            "below": "<",
            "equal": "==",
            "not_equal": "!=",
            "greater_equal": ">=",
            "less_equal": "<=",
            "crosses_above": "crosses_above",
            "crosses_below": "crosses_below"
        }
        
        logger.info("Code Generator initialized successfully")
    
    def generate_strategy(self, parsed_strategy: Dict[str, Any]) -> str:
        """
        Generate complete Python strategy code
        
        Args:
            parsed_strategy: Parsed strategy data from StrategyParser
            
        Returns:
            Generated Python code as string
        """
        try:
            strategy_name = parsed_strategy.get("strategy_name", "UnnamedStrategy")
            description = parsed_strategy.get("description", "Auto-generated trading strategy")
            timeframe = parsed_strategy.get("timeframe", "1d")
            
            # Generate strategy code
            code_parts = []
            
            # Add header
            code_parts.append(self._generate_header(strategy_name, description))
            
            # Add imports
            code_parts.append(self._generate_imports(parsed_strategy))
            
            # Add strategy class
            code_parts.append(self._generate_strategy_class(parsed_strategy))
            
            # Add indicator calculations
            code_parts.append(self._generate_indicators_section(parsed_strategy))
            
            # Add buy conditions
            code_parts.append(self._generate_buy_conditions(parsed_strategy))
            
            # Add sell conditions  
            code_parts.append(self._generate_sell_conditions(parsed_strategy))
            
            # Add money management
            code_parts.append(self._generate_money_management(parsed_strategy))
            
            # Add main execution
            code_parts.append(self._generate_main_execution(parsed_strategy))
            
            # Add footer
            code_parts.append(self._generate_footer())
            
            # Combine all parts
            generated_code = "\n\n".join(code_parts)
            
            # Store generated strategy
            self.generated_strategies.append({
                "name": strategy_name,
                "code": generated_code,
                "timestamp": datetime.now().isoformat(),
                "indicators": parsed_strategy.get("indicators_used", [])
            })
            
            logger.info(f"Strategy code generated successfully: {strategy_name}")
            return generated_code
            
        except Exception as e:
            logger.error(f"Code generation error: {str(e)}")
            raise ValueError(f"Failed to generate strategy code: {str(e)}")
    
    def _generate_header(self, strategy_name: str, description: str) -> str:
        """Generate file header with metadata"""
        return f'''"""
{strategy_name}
{description}

Auto-generated by Strategy Builder
Generated on: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
"""'''
    
    def _generate_imports(self, parsed_strategy: Dict[str, Any]) -> str:
        """Generate import statements"""
        imports = [
            "import pandas as pd",
            "import numpy as np",
            "import talib",
            "from typing import Dict, List, Optional, Tuple",
            "from datetime import datetime, timedelta",
            "import logging"
        ]
        
        # Add specific imports based on indicators used
        indicators_used = parsed_strategy.get("indicators_used", [])
        
        if any(ind in ["RSI", "MACD", "BB", "STOCH", "CCI", "WILLIAMS", "ATR", "ADX"] for ind in indicators_used):
            imports.append("import talib")
        
        if "MACD" in indicators_used:
            imports.append("from talib import MACD")
        
        return "\n".join(imports)
    
    def _generate_strategy_class(self, parsed_strategy: Dict[str, Any]) -> str:
        """Generate main strategy class"""
        strategy_name = parsed_strategy.get("strategy_name", "Strategy").replace(" ", "")
        timeframe = parsed_strategy.get("timeframe", "1d")
        
        return f'''class {strategy_name}:
    """
    Trading Strategy: {parsed_strategy.get("strategy_name", "Unnamed")}
    Timeframe: {timeframe}
    """
    
    def __init__(self, initial_capital: float = {parsed_strategy.get("money_management", {}).get("initial_capital", 100000)}):
        self.initial_capital = initial_capital
        self.current_capital = initial_capital
        self.positions = []
        self.trades = []
        self.timeframe = "{timeframe}"
        
        # Money management settings
        self.position_size = {parsed_strategy.get("money_management", {}).get("position_size", 10)}  # Percentage
        self.max_risk = {parsed_strategy.get("money_management", {}).get("max_risk", 2)}  # Percentage
        self.profit_target = {parsed_strategy.get("money_management", {}).get("profit_target", 5)}  # Percentage
        self.max_positions = {parsed_strategy.get("money_management", {}).get("max_positions", 1)}
        self.commission = {parsed_strategy.get("money_management", {}).get("commission", 0.001)}  # 0.1%
        
        # Strategy statistics
        self.total_trades = 0
        self.winning_trades = 0
        self.losing_trades = 0
        
        # Initialize logger
        self.logger = logging.getLogger(__name__)
        self.logger.info(f"Strategy initialized: {strategy_name}")
    
    def calculate_position_size(self, price: float) -> int:
        """Calculate position size based on current capital and risk management"""
        available_capital = self.current_capital * (self.position_size / 100)
        position_value = available_capital * (1 - self.commission)
        shares = int(position_value / price)
        return max(1, shares)  # Minimum 1 share
    
    def log_trade(self, action: str, price: float, quantity: int, timestamp: datetime):
        """Log trade details"""
        trade = {{
            "timestamp": timestamp,
            "action": action,
            "price": price,
            "quantity": quantity,
            "value": price * quantity,
            "commission": price * quantity * self.commission
        }}
        self.trades.append(trade)
        self.total_trades += 1
        self.logger.info(f"Trade executed: {{action}} {{quantity}} shares at ${{price:.2f}}")'''
    
    def _generate_indicators_section(self, parsed_strategy: Dict[str, Any]) -> str:
        """Generate indicator calculation methods"""
        indicators_used = parsed_strategy.get("indicators_used", [])
        
        if not indicators_used:
            return "    # No indicators used in this strategy"
        
        code_parts = ["    def calculate_indicators(self, data: pd.DataFrame) -> pd.DataFrame:",
                     '        """Calculate all required indicators"""',
                     "        df = data.copy()"]
        
        # Generate code for each indicator
        for indicator in indicators_used:
            if indicator in self.indicator_templates:
                indicator_code = self.indicator_templates[indicator]()
                code_parts.append(f"        # Calculate {indicator}")
                code_parts.extend([f"        {line}" for line in indicator_code.split('\n')])
                code_parts.append("")
        
        code_parts.extend([
            "        return df",
            ""
        ])
        
        return "\n".join(code_parts)
    
    def _generate_buy_conditions(self, parsed_strategy: Dict[str, Any]) -> str:
        """Generate buy signal logic"""
        buy_conditions = parsed_strategy.get("buy_conditions", [])
        
        code_parts = [
            "    def check_buy_signals(self, data: pd.DataFrame, index: int) -> bool:",
            '        """Check if buy conditions are met"""',
            "        if index < 50:  # Need enough data for indicators",
            "            return False",
            ""
        ]
        
        if not buy_conditions:
            code_parts.extend([
                "        # No buy conditions defined",
                "        return False"
            ])
        else:
            code_parts.append("        # Buy conditions")
            
            for i, condition in enumerate(buy_conditions):
                condition_code = self._generate_condition_code(condition, "buy", i)
                code_parts.append(f"        condition_{i} = {condition_code}")
            
            # Combine conditions with logic
            if len(buy_conditions) == 1:
                code_parts.append("        return condition_0")
            else:
                logic_parts = []
                for i in range(len(buy_conditions)):
                    logic = buy_conditions[i].get('logic', 'AND')
                    if i == 0:
                        logic_parts.append(f"condition_{i}")
                    else:
                        if logic == 'OR':
                            logic_parts.append(f" or condition_{i}")
                        else:  # AND
                            logic_parts.append(f" and condition_{i}")
                
                code_parts.append(f"        return {''.join(logic_parts)}")
        
        code_parts.append("")
        return "\n".join(code_parts)
    
    def _generate_sell_conditions(self, parsed_strategy: Dict[str, Any]) -> str:
        """Generate sell signal logic"""
        sell_conditions = parsed_strategy.get("sell_conditions", [])
        money_mgmt = parsed_strategy.get("money_management", {})
        
        code_parts = [
            "    def check_sell_signals(self, data: pd.DataFrame, index: int, entry_price: float) -> Tuple[bool, str]:",
            '        """Check if sell conditions are met"""',
            "        current_price = data['close'].iloc[index]",
            "        price_change = (current_price - entry_price) / entry_price * 100",
            ""
        ]
        
        # Add stop loss and take profit logic
        max_risk = money_mgmt.get("max_risk", 2)
        profit_target = money_mgmt.get("profit_target", 5)
        
        code_parts.extend([
            "        # Stop loss and take profit",
            f"        if price_change <= -{max_risk}:",
            '            return True, "stop_loss"',
            f"        if price_change >= {profit_target}:",
            '            return True, "take_profit"',
            ""
        ])
        
        if sell_conditions:
            code_parts.append("        # Custom sell conditions")
            
            for i, condition in enumerate(sell_conditions):
                condition_code = self._generate_condition_code(condition, "sell", i)
                code_parts.append(f"        sell_condition_{i} = {condition_code}")
            
            # Combine sell conditions
            if len(sell_conditions) == 1:
                code_parts.append('        if sell_condition_0:')
                code_parts.append('            return True, "custom_signal"')
            else:
                logic_parts = []
                for i in range(len(sell_conditions)):
                    logic = sell_conditions[i].get('logic', 'AND')
                    if i == 0:
                        logic_parts.append(f"sell_condition_{i}")
                    else:
                        if logic == 'OR':
                            logic_parts.append(f" or sell_condition_{i}")
                        else:  # AND
                            logic_parts.append(f" and sell_condition_{i}")
                
                code_parts.append(f"        if {''.join(logic_parts)}:")
                code_parts.append('            return True, "custom_signal"')
        
        code_parts.extend([
            "",
            '        return False, "hold"'
        ])
        
        code_parts.append("")
        return "\n".join(code_parts)
    
    def _generate_condition_code(self, condition: Dict, condition_type: str, index: int) -> str:
        """Generate code for individual condition"""
        try:
            left = condition.get("left", {})
            right = condition.get("right", {})
            operator = condition.get("operator", "")
            
            # Generate left side code
            left_indicator = left.get("indicator", "")
            left_code = self._generate_indicator_reference(left_indicator, left, "data", "index")
            
            # Generate right side code
            right_indicator = right.get("indicator", "")
            if right_indicator == "CUSTOM":
                right_code = str(right.get("custom_value", 0))
            else:
                right_code = self._generate_indicator_reference(right_indicator, right, "data", "index")
            
            # Generate operator code
            op_symbol = self.operator_templates.get(operator, operator)
            
            if operator in ["crosses_above", "crosses_below"]:
                if operator == "crosses_above":
                    return f"({left_code} > {right_code}) and (data['{left_indicator.lower()}'].iloc[index-1] <= data['{right_indicator.lower()}'].iloc[index-1])"
                else:  # crosses_below
                    return f"({left_code} < {right_code}) and (data['{left_indicator.lower()}'].iloc[index-1] >= data['{right_indicator.lower()}'].iloc[index-1])"
            else:
                return f"{left_code} {op_symbol} {right_code}"
                
        except Exception as e:
            logger.error(f"Error generating condition code: {str(e)}")
            return "False  # Error in condition"
    
    def _generate_indicator_reference(self, indicator: str, params: Dict, data_var: str, index_var: str) -> str:
        """Generate code to reference indicator value"""
        if indicator == "CUSTOM":
            return str(params.get("custom_value", 0))
        
        indicator_lower = indicator.lower()
        period = params.get("period", 14)
        
        if indicator in ["RSI", "CCI", "WILLIAMS", "ATR", "ADX"]:
            return f"{data_var}['{indicator_lower}'].iloc[{index_var}]"
        elif indicator in ["EMA", "SMA"]:
            return f"{data_var}['{indicator_lower}_{period}'].iloc[{index_var}]"
        elif indicator == "MACD":
            return f"{data_var}['macd'].iloc[{index_var}]"
        elif indicator == "BB":
            source = params.get("source", "close")
            if source == "upper":
                return f"{data_var}['bb_upper'].iloc[{index_var}]"
            elif source == "lower":
                return f"{data_var}['bb_lower'].iloc[{index_var}]"
            else:
                return f"{data_var}['bb_middle'].iloc[{index_var}]"
        elif indicator == "STOCH":
            return f"{data_var}['stoch_k'].iloc[{index_var}]"
        else:
            return f"{data_var}['{indicator_lower}'].iloc[{index_var}]"
    
    def _generate_money_management(self, parsed_strategy: Dict[str, Any]) -> str:
        """Generate money management methods"""
        return '''    def execute_trade(self, action: str, data: pd.DataFrame, index: int) -> bool:
        """Execute buy or sell trade"""
        try:
            current_price = data['close'].iloc[index]
            timestamp = data.index[index] if hasattr(data.index[index], 'strftime') else datetime.now()
            
            if action == "BUY":
                # Check if we can open new position
                if len(self.positions) >= self.max_positions:
                    return False
                
                quantity = self.calculate_position_size(current_price)
                trade_value = current_price * quantity
                commission = trade_value * self.commission
                total_cost = trade_value + commission
                
                if total_cost <= self.current_capital:
                    # Execute buy
                    self.current_capital -= total_cost
                    position = {
                        "entry_price": current_price,
                        "quantity": quantity,
                        "entry_time": timestamp,
                        "entry_index": index
                    }
                    self.positions.append(position)
                    self.log_trade("BUY", current_price, quantity, timestamp)
                    return True
                    
            elif action == "SELL" and self.positions:
                # Close oldest position
                position = self.positions.pop(0)
                quantity = position["quantity"]
                entry_price = position["entry_price"]
                
                trade_value = current_price * quantity
                commission = trade_value * self.commission
                net_proceeds = trade_value - commission
                
                # Calculate profit/loss
                profit_loss = net_proceeds - (entry_price * quantity)
                self.current_capital += net_proceeds
                
                # Update statistics
                if profit_loss > 0:
                    self.winning_trades += 1
                else:
                    self.losing_trades += 1
                
                self.log_trade("SELL", current_price, quantity, timestamp)
                return True
                
            return False
            
        except Exception as e:
            self.logger.error(f"Trade execution error: {str(e)}")
            return False'''
    
    def _generate_main_execution(self, parsed_strategy: Dict[str, Any]) -> str:
        """Generate main strategy execution method"""
        return '''    def run_strategy(self, data: pd.DataFrame) -> Dict[str, Any]:
        """Run the complete trading strategy"""
        try:
            # Calculate indicators
            data = self.calculate_indicators(data)
            
            # Track strategy performance
            equity_curve = []
            signals = []
            
            for i in range(len(data)):
                current_equity = self.current_capital
                
                # Add value of open positions
                if self.positions:
                    current_price = data['close'].iloc[i]
                    for position in self.positions:
                        position_value = position["quantity"] * current_price
                        current_equity += position_value
                
                equity_curve.append(current_equity)
                
                # Check for buy signals
                if not self.positions and self.check_buy_signals(data, i):
                    if self.execute_trade("BUY", data, i):
                        signals.append({"index": i, "type": "BUY", "price": data['close'].iloc[i]})
                
                # Check for sell signals
                elif self.positions:
                    for position in self.positions[:]:  # Copy to avoid modification during iteration
                        should_sell, reason = self.check_sell_signals(data, i, position["entry_price"])
                        if should_sell:
                            if self.execute_trade("SELL", data, i):
                                signals.append({"index": i, "type": "SELL", "price": data['close'].iloc[i], "reason": reason})
                            break
            
            # Close any remaining positions
            if self.positions and len(data) > 0:
                final_price = data['close'].iloc[-1]
                timestamp = data.index[-1] if hasattr(data.index[-1], 'strftime') else datetime.now()
                while self.positions:
                    self.execute_trade("SELL", data, len(data)-1)
            
            # Calculate performance metrics
            final_equity = equity_curve[-1] if equity_curve else self.initial_capital
            total_return = (final_equity - self.initial_capital) / self.initial_capital * 100
            win_rate = (self.winning_trades / max(1, self.total_trades)) * 100
            
            results = {
                "initial_capital": self.initial_capital,
                "final_capital": final_equity,
                "total_return": total_return,
                "total_trades": self.total_trades,
                "winning_trades": self.winning_trades,
                "losing_trades": self.losing_trades,
                "win_rate": win_rate,
                "equity_curve": equity_curve,
                "signals": signals,
                "trades": self.trades
            }
            
            self.logger.info(f"Strategy completed. Total return: {total_return:.2f}%")
            return results
            
        except Exception as e:
            self.logger.error(f"Strategy execution error: {str(e)}")
            return {"error": str(e)}'''
    
    def _generate_footer(self) -> str:
        """Generate file footer with usage example"""
        return '''

def load_data(symbol: str = "SPY", days: int = 365) -> pd.DataFrame:
    """Load sample data for backtesting"""
    # This is a placeholder - replace with your data loading logic
    try:
        # Example using yfinance (install with: pip install yfinance)
        import yfinance as yf
        ticker = yf.Ticker(symbol)
        data = ticker.history(period=f"{days}d")
        return data
    except ImportError:
        # Generate sample data if yfinance not available
        dates = pd.date_range(start=datetime.now() - timedelta(days=days), end=datetime.now(), freq='D')
        np.random.seed(42)
        
        # Generate realistic price data
        initial_price = 100
        returns = np.random.normal(0.001, 0.02, len(dates))
        prices = [initial_price]
        
        for return_rate in returns[1:]:
            new_price = prices[-1] * (1 + return_rate)
            prices.append(new_price)
        
        data = pd.DataFrame({
            'open': prices,
            'high': [p * (1 + abs(np.random.normal(0, 0.01))) for p in prices],
            'low': [p * (1 - abs(np.random.normal(0, 0.01))) for p in prices],
            'close': prices,
            'volume': np.random.randint(100000, 1000000, len(dates))
        }, index=dates)
        
        return data

if __name__ == "__main__":
    # Example usage
    print("Loading data...")
    data = load_data("SPY", 365)
    
    print("Running strategy...")
    strategy = {strategy_class_name}()
    results = strategy.run_strategy(data)
    
    if "error" not in results:
        print(f"\\nStrategy Results:")
        print(f"Initial Capital: ${results['initial_capital']:,.2f}")
        print(f"Final Capital: ${results['final_capital']:,.2f}")
        print(f"Total Return: {results['total_return']:.2f}%")
        print(f"Total Trades: {results['total_trades']}")
        print(f"Win Rate: {results['win_rate']:.2f}%")
        print(f"Signals Generated: {len(results['signals'])}")
    else:
        print(f"Strategy error: {results['error']}")'''.replace("{strategy_class_name}", "Strategy")
    
    # Indicator calculation methods
    def _generate_rsi_code(self) -> str:
        """Generate RSI calculation code"""
        return '''df['rsi'] = talib.RSI(df['close'].values, timeperiod=14)'''
    
    def _generate_ema_code(self) -> str:
        """Generate EMA calculation code"""
        return '''df['ema_20'] = talib.EMA(df['close'].values, timeperiod=20)
df['ema_50'] = talib.EMA(df['close'].values, timeperiod=50)'''
    
    def _generate_sma_code(self) -> str:
        """Generate SMA calculation code"""
        return '''df['sma_20'] = talib.SMA(df['close'].values, timeperiod=20)
df['sma_50'] = talib.SMA(df['close'].values, timeperiod=50)'''
    
    def _generate_macd_code(self) -> str:
        """Generate MACD calculation code"""
        return '''macd, macd_signal, macd_hist = talib.MACD(df['close'].values, fastperiod=12, slowperiod=26, signalperiod=9)
df['macd'] = macd
df['macd_signal'] = macd_signal
df['macd_hist'] = macd_hist'''
    
    def _generate_bb_code(self) -> str:
        """Generate Bollinger Bands calculation code"""
        return '''bb_upper, bb_middle, bb_lower = talib.BBANDS(df['close'].values, timeperiod=20, nbdevup=2, nbdevdn=2)
df['bb_upper'] = bb_upper
df['bb_middle'] = bb_middle
df['bb_lower'] = bb_lower'''
    
    def _generate_stoch_code(self) -> str:
        """Generate Stochastic calculation code"""
        return '''stoch_k, stoch_d = talib.STOCH(df['high'].values, df['low'].values, df['close'].values, 
                                    fastk_period=14, slowk_period=3, slowd_period=3)
df['stoch_k'] = stoch_k
df['stoch_d'] = stoch_d'''
    
    def _generate_cci_code(self) -> str:
        """Generate CCI calculation code"""
        return '''df['cci'] = talib.CCI(df['high'].values, df['low'].values, df['close'].values, timeperiod=20)'''
    
    def _generate_williams_code(self) -> str:
        """Generate Williams %R calculation code"""
        return '''df['williams'] = talib.WILLR(df['high'].values, df['low'].values, df['close'].values, timeperiod=14)'''
    
    def _generate_atr_code(self) -> str:
        """Generate ATR calculation code"""
        return '''df['atr'] = talib.ATR(df['high'].values, df['low'].values, df['close'].values, timeperiod=14)'''
    
    def _generate_adx_code(self) -> str:
        """Generate ADX calculation code"""
        return '''df['adx'] = talib.ADX(df['high'].values, df['low'].values, df['close'].values, timeperiod=14)'''
    
    def validate_templates(self) -> Dict[str, bool]:
        """Validate if template files exist"""
        template_status = {}
        
        # Check if templates directory exists
        if os.path.exists(self.templates_dir):
            template_status["directory_exists"] = True
            
            # Check for specific template files
            template_files = ["strategy_base.py", "indicators.py", "backtest.py"]
            for template_file in template_files:
                file_path = os.path.join(self.templates_dir, template_file)
                template_status[template_file] = os.path.exists(file_path)
        else:
            template_status["directory_exists"] = False
        
        # Check if we have indicator templates
        template_status["indicator_templates"] = len(self.indicator_templates) > 0
        template_status["operator_templates"] = len(self.operator_templates) > 0
        
        return template_status
    
    def get_available_templates(self) -> List[str]:
        """Get list of available strategy templates"""
        templates = ["basic_strategy", "rsi_strategy", "ema_crossover", "bollinger_bands"]
        
        # Check if custom templates exist
        if os.path.exists(self.templates_dir):
            try:
                template_files = [f for f in os.listdir(self.templates_dir) if f.endswith('.py')]
                templates.extend([f.replace('.py', '') for f in template_files])
            except Exception as e:
                logger.warning(f"Could not read templates directory: {str(e)}")
        
        return list(set(templates))  # Remove duplicates
    
    def save_generated_strategy(self, strategy_name: str, code: str, output_dir: str = "generated_strategies") -> bool:
        """Save generated strategy to file"""
        try:
            if not os.path.exists(output_dir):
                os.makedirs(output_dir)
            
            # Clean strategy name for filename
            filename = "".join(c for c in strategy_name if c.isalnum() or c in (' ', '-', '_')).rstrip()
            filename = filename.replace(' ', '_').lower()
            filepath = os.path.join(output_dir, f"{filename}.py")
            
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(code)
            
            logger.info(f"Strategy saved to: {filepath}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to save strategy: {str(e)}")
            return False
    
    def get_generation_stats(self) -> Dict[str, Any]:
        """Get statistics about generated strategies"""
        return {
            "total_generated": len(self.generated_strategies),
            "strategies": [
                {
                    "name": strategy["name"],
                    "timestamp": strategy["timestamp"],
                    "indicators_count": len(strategy["indicators"])
                }
                for strategy in self.generated_strategies
            ],
            "unique_indicators": list(set([
                ind for strategy in self.generated_strategies
                for ind in strategy["indicators"]
            ]))
        }


# Helper functions
def create_sample_strategy_code() -> str:
    """Create a sample strategy for testing"""
    generator = CodeGenerator()
    
    sample_strategy = {
        "strategy_name": "Sample RSI Strategy",
        "description": "Simple RSI-based strategy for testing",
        "timeframe": "1d",
        "indicators_used": ["RSI"],
        "buy_conditions": [
            {
                "left": {"indicator": "RSI", "period": 14},
                "operator": "below",
                "right": {"indicator": "CUSTOM", "custom_value": 30},
                "logic": "AND"
            }
        ],
        "sell_conditions": [
            {
                "left": {"indicator": "RSI", "period": 14},
                "operator": "above", 
                "right": {"indicator": "CUSTOM", "custom_value": 70},
                "logic": "AND"
            }
        ],
        "money_management": {
            "position_size": 10,
            "max_risk": 2,
            "profit_target": 5,
            "max_positions": 1,
            "initial_capital": 100000,
            "commission": 0.001
        }
    }
    
    return generator.generate_strategy(sample_strategy)


# Initialize generator instance for module-level use
code_generator = CodeGenerator()

if __name__ == "__main__":
    # Test the generator
    print("Testing Code Generator...")
    
    # Generate sample strategy
    sample_code = create_sample_strategy_code()
    print(f"Generated {len(sample_code)} characters of code")
    
    # Test template validation
    generator = CodeGenerator()
    template_status = generator.validate_templates()
    print(f"Template validation: {template_status}")
    
    # Get available templates
    templates = generator.get_available_templates()
    print(f"Available templates: {templates}")
    
    print("Code Generator test completed!")